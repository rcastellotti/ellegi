// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: livegrep.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_livegrep_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_livegrep_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "config.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_livegrep_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_livegrep_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_livegrep_2eproto;
class Bounds;
struct BoundsDefaultTypeInternal;
extern BoundsDefaultTypeInternal _Bounds_default_instance_;
class CodeSearchResult;
struct CodeSearchResultDefaultTypeInternal;
extern CodeSearchResultDefaultTypeInternal _CodeSearchResult_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class FileResult;
struct FileResultDefaultTypeInternal;
extern FileResultDefaultTypeInternal _FileResult_default_instance_;
class InfoRequest;
struct InfoRequestDefaultTypeInternal;
extern InfoRequestDefaultTypeInternal _InfoRequest_default_instance_;
class Query;
struct QueryDefaultTypeInternal;
extern QueryDefaultTypeInternal _Query_default_instance_;
class SearchResult;
struct SearchResultDefaultTypeInternal;
extern SearchResultDefaultTypeInternal _SearchResult_default_instance_;
class SearchStats;
struct SearchStatsDefaultTypeInternal;
extern SearchStatsDefaultTypeInternal _SearchStats_default_instance_;
class ServerInfo;
struct ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class ServerInfo_Tree;
struct ServerInfo_TreeDefaultTypeInternal;
extern ServerInfo_TreeDefaultTypeInternal _ServerInfo_Tree_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Bounds* Arena::CreateMaybeMessage<::Bounds>(Arena*);
template<> ::CodeSearchResult* Arena::CreateMaybeMessage<::CodeSearchResult>(Arena*);
template<> ::Empty* Arena::CreateMaybeMessage<::Empty>(Arena*);
template<> ::FileResult* Arena::CreateMaybeMessage<::FileResult>(Arena*);
template<> ::InfoRequest* Arena::CreateMaybeMessage<::InfoRequest>(Arena*);
template<> ::Query* Arena::CreateMaybeMessage<::Query>(Arena*);
template<> ::SearchResult* Arena::CreateMaybeMessage<::SearchResult>(Arena*);
template<> ::SearchStats* Arena::CreateMaybeMessage<::SearchStats>(Arena*);
template<> ::ServerInfo* Arena::CreateMaybeMessage<::ServerInfo>(Arena*);
template<> ::ServerInfo_Tree* Arena::CreateMaybeMessage<::ServerInfo_Tree>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum SearchStats_ExitReason : int {
  SearchStats_ExitReason_NONE = 0,
  SearchStats_ExitReason_TIMEOUT = 1,
  SearchStats_ExitReason_MATCH_LIMIT = 2,
  SearchStats_ExitReason_SearchStats_ExitReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SearchStats_ExitReason_SearchStats_ExitReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SearchStats_ExitReason_IsValid(int value);
constexpr SearchStats_ExitReason SearchStats_ExitReason_ExitReason_MIN = SearchStats_ExitReason_NONE;
constexpr SearchStats_ExitReason SearchStats_ExitReason_ExitReason_MAX = SearchStats_ExitReason_MATCH_LIMIT;
constexpr int SearchStats_ExitReason_ExitReason_ARRAYSIZE = SearchStats_ExitReason_ExitReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SearchStats_ExitReason_descriptor();
template<typename T>
inline const std::string& SearchStats_ExitReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SearchStats_ExitReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SearchStats_ExitReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SearchStats_ExitReason_descriptor(), enum_t_value);
}
inline bool SearchStats_ExitReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SearchStats_ExitReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SearchStats_ExitReason>(
    SearchStats_ExitReason_descriptor(), name, value);
}
// ===================================================================

class Query final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Query) */ {
 public:
  inline Query() : Query(nullptr) {}
  ~Query() override;
  explicit constexpr Query(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Query(const Query& from);
  Query(Query&& from) noexcept
    : Query() {
    *this = ::std::move(from);
  }

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  inline Query& operator=(Query&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Query& default_instance() {
    return *internal_default_instance();
  }
  static inline const Query* internal_default_instance() {
    return reinterpret_cast<const Query*>(
               &_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Query& a, Query& b) {
    a.Swap(&b);
  }
  inline void Swap(Query* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Query* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Query* New() const final {
    return new Query();
  }

  Query* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Query>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Query& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Query& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Query* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Query";
  }
  protected:
  explicit Query(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileFieldNumber = 2,
    kNotFileFieldNumber = 6,
    kLineFieldNumber = 1,
    kRepoFieldNumber = 3,
    kTagsFieldNumber = 4,
    kNotRepoFieldNumber = 7,
    kNotTagsFieldNumber = 8,
    kFoldCaseFieldNumber = 5,
    kFilenameOnlyFieldNumber = 10,
    kMaxMatchesFieldNumber = 9,
    kContextLinesFieldNumber = 11,
  };
  // repeated string file = 2;
  int file_size() const;
  private:
  int _internal_file_size() const;
  public:
  void clear_file();
  const std::string& file(int index) const;
  std::string* mutable_file(int index);
  void set_file(int index, const std::string& value);
  void set_file(int index, std::string&& value);
  void set_file(int index, const char* value);
  void set_file(int index, const char* value, size_t size);
  std::string* add_file();
  void add_file(const std::string& value);
  void add_file(std::string&& value);
  void add_file(const char* value);
  void add_file(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& file() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_file();
  private:
  const std::string& _internal_file(int index) const;
  std::string* _internal_add_file();
  public:

  // repeated string not_file = 6;
  int not_file_size() const;
  private:
  int _internal_not_file_size() const;
  public:
  void clear_not_file();
  const std::string& not_file(int index) const;
  std::string* mutable_not_file(int index);
  void set_not_file(int index, const std::string& value);
  void set_not_file(int index, std::string&& value);
  void set_not_file(int index, const char* value);
  void set_not_file(int index, const char* value, size_t size);
  std::string* add_not_file();
  void add_not_file(const std::string& value);
  void add_not_file(std::string&& value);
  void add_not_file(const char* value);
  void add_not_file(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& not_file() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_not_file();
  private:
  const std::string& _internal_not_file(int index) const;
  std::string* _internal_add_not_file();
  public:

  // string line = 1;
  void clear_line();
  const std::string& line() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line();
  PROTOBUF_MUST_USE_RESULT std::string* release_line();
  void set_allocated_line(std::string* line);
  private:
  const std::string& _internal_line() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line(const std::string& value);
  std::string* _internal_mutable_line();
  public:

  // string repo = 3;
  void clear_repo();
  const std::string& repo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_repo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_repo();
  PROTOBUF_MUST_USE_RESULT std::string* release_repo();
  void set_allocated_repo(std::string* repo);
  private:
  const std::string& _internal_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_repo(const std::string& value);
  std::string* _internal_mutable_repo();
  public:

  // string tags = 4;
  void clear_tags();
  const std::string& tags() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tags(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tags();
  PROTOBUF_MUST_USE_RESULT std::string* release_tags();
  void set_allocated_tags(std::string* tags);
  private:
  const std::string& _internal_tags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tags(const std::string& value);
  std::string* _internal_mutable_tags();
  public:

  // string not_repo = 7;
  void clear_not_repo();
  const std::string& not_repo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_not_repo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_not_repo();
  PROTOBUF_MUST_USE_RESULT std::string* release_not_repo();
  void set_allocated_not_repo(std::string* not_repo);
  private:
  const std::string& _internal_not_repo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_not_repo(const std::string& value);
  std::string* _internal_mutable_not_repo();
  public:

  // string not_tags = 8;
  void clear_not_tags();
  const std::string& not_tags() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_not_tags(ArgT0&& arg0, ArgT... args);
  std::string* mutable_not_tags();
  PROTOBUF_MUST_USE_RESULT std::string* release_not_tags();
  void set_allocated_not_tags(std::string* not_tags);
  private:
  const std::string& _internal_not_tags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_not_tags(const std::string& value);
  std::string* _internal_mutable_not_tags();
  public:

  // bool fold_case = 5;
  void clear_fold_case();
  bool fold_case() const;
  void set_fold_case(bool value);
  private:
  bool _internal_fold_case() const;
  void _internal_set_fold_case(bool value);
  public:

  // bool filename_only = 10;
  void clear_filename_only();
  bool filename_only() const;
  void set_filename_only(bool value);
  private:
  bool _internal_filename_only() const;
  void _internal_set_filename_only(bool value);
  public:

  // int32 max_matches = 9;
  void clear_max_matches();
  ::PROTOBUF_NAMESPACE_ID::int32 max_matches() const;
  void set_max_matches(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_matches() const;
  void _internal_set_max_matches(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 context_lines = 11;
  void clear_context_lines();
  ::PROTOBUF_NAMESPACE_ID::int32 context_lines() const;
  void set_context_lines(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_context_lines() const;
  void _internal_set_context_lines(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Query)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> file_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> not_file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr repo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_repo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_tags_;
  bool fold_case_;
  bool filename_only_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_matches_;
  ::PROTOBUF_NAMESPACE_ID::int32 context_lines_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livegrep_2eproto;
};
// -------------------------------------------------------------------

class Bounds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Bounds) */ {
 public:
  inline Bounds() : Bounds(nullptr) {}
  ~Bounds() override;
  explicit constexpr Bounds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Bounds(const Bounds& from);
  Bounds(Bounds&& from) noexcept
    : Bounds() {
    *this = ::std::move(from);
  }

  inline Bounds& operator=(const Bounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bounds& operator=(Bounds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bounds& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bounds* internal_default_instance() {
    return reinterpret_cast<const Bounds*>(
               &_Bounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Bounds& a, Bounds& b) {
    a.Swap(&b);
  }
  inline void Swap(Bounds* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bounds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bounds* New() const final {
    return new Bounds();
  }

  Bounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bounds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Bounds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Bounds& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bounds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Bounds";
  }
  protected:
  explicit Bounds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 1,
    kRightFieldNumber = 2,
  };
  // int32 left = 1;
  void clear_left();
  ::PROTOBUF_NAMESPACE_ID::int32 left() const;
  void set_left(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_left() const;
  void _internal_set_left(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 right = 2;
  void clear_right();
  ::PROTOBUF_NAMESPACE_ID::int32 right() const;
  void set_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_right() const;
  void _internal_set_right(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Bounds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 left_;
  ::PROTOBUF_NAMESPACE_ID::int32 right_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livegrep_2eproto;
};
// -------------------------------------------------------------------

class SearchResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SearchResult) */ {
 public:
  inline SearchResult() : SearchResult(nullptr) {}
  ~SearchResult() override;
  explicit constexpr SearchResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchResult(const SearchResult& from);
  SearchResult(SearchResult&& from) noexcept
    : SearchResult() {
    *this = ::std::move(from);
  }

  inline SearchResult& operator=(const SearchResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResult& operator=(SearchResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchResult* internal_default_instance() {
    return reinterpret_cast<const SearchResult*>(
               &_SearchResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SearchResult& a, SearchResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchResult* New() const final {
    return new SearchResult();
  }

  SearchResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SearchResult";
  }
  protected:
  explicit SearchResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContextBeforeFieldNumber = 5,
    kContextAfterFieldNumber = 6,
    kTreeFieldNumber = 1,
    kVersionFieldNumber = 2,
    kPathFieldNumber = 3,
    kLineFieldNumber = 8,
    kBoundsFieldNumber = 7,
    kLineNumberFieldNumber = 4,
  };
  // repeated string context_before = 5;
  int context_before_size() const;
  private:
  int _internal_context_before_size() const;
  public:
  void clear_context_before();
  const std::string& context_before(int index) const;
  std::string* mutable_context_before(int index);
  void set_context_before(int index, const std::string& value);
  void set_context_before(int index, std::string&& value);
  void set_context_before(int index, const char* value);
  void set_context_before(int index, const char* value, size_t size);
  std::string* add_context_before();
  void add_context_before(const std::string& value);
  void add_context_before(std::string&& value);
  void add_context_before(const char* value);
  void add_context_before(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& context_before() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_context_before();
  private:
  const std::string& _internal_context_before(int index) const;
  std::string* _internal_add_context_before();
  public:

  // repeated string context_after = 6;
  int context_after_size() const;
  private:
  int _internal_context_after_size() const;
  public:
  void clear_context_after();
  const std::string& context_after(int index) const;
  std::string* mutable_context_after(int index);
  void set_context_after(int index, const std::string& value);
  void set_context_after(int index, std::string&& value);
  void set_context_after(int index, const char* value);
  void set_context_after(int index, const char* value, size_t size);
  std::string* add_context_after();
  void add_context_after(const std::string& value);
  void add_context_after(std::string&& value);
  void add_context_after(const char* value);
  void add_context_after(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& context_after() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_context_after();
  private:
  const std::string& _internal_context_after(int index) const;
  std::string* _internal_add_context_after();
  public:

  // string tree = 1;
  void clear_tree();
  const std::string& tree() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tree(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tree();
  PROTOBUF_MUST_USE_RESULT std::string* release_tree();
  void set_allocated_tree(std::string* tree);
  private:
  const std::string& _internal_tree() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tree(const std::string& value);
  std::string* _internal_mutable_tree();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string path = 3;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string line = 8;
  void clear_line();
  const std::string& line() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line();
  PROTOBUF_MUST_USE_RESULT std::string* release_line();
  void set_allocated_line(std::string* line);
  private:
  const std::string& _internal_line() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line(const std::string& value);
  std::string* _internal_mutable_line();
  public:

  // .Bounds bounds = 7;
  bool has_bounds() const;
  private:
  bool _internal_has_bounds() const;
  public:
  void clear_bounds();
  const ::Bounds& bounds() const;
  PROTOBUF_MUST_USE_RESULT ::Bounds* release_bounds();
  ::Bounds* mutable_bounds();
  void set_allocated_bounds(::Bounds* bounds);
  private:
  const ::Bounds& _internal_bounds() const;
  ::Bounds* _internal_mutable_bounds();
  public:
  void unsafe_arena_set_allocated_bounds(
      ::Bounds* bounds);
  ::Bounds* unsafe_arena_release_bounds();

  // int64 line_number = 4;
  void clear_line_number();
  ::PROTOBUF_NAMESPACE_ID::int64 line_number() const;
  void set_line_number(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_line_number() const;
  void _internal_set_line_number(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:SearchResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> context_before_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> context_after_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tree_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_;
  ::Bounds* bounds_;
  ::PROTOBUF_NAMESPACE_ID::int64 line_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livegrep_2eproto;
};
// -------------------------------------------------------------------

class FileResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileResult) */ {
 public:
  inline FileResult() : FileResult(nullptr) {}
  ~FileResult() override;
  explicit constexpr FileResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileResult(const FileResult& from);
  FileResult(FileResult&& from) noexcept
    : FileResult() {
    *this = ::std::move(from);
  }

  inline FileResult& operator=(const FileResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileResult& operator=(FileResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileResult* internal_default_instance() {
    return reinterpret_cast<const FileResult*>(
               &_FileResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FileResult& a, FileResult& b) {
    a.Swap(&b);
  }
  inline void Swap(FileResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileResult* New() const final {
    return new FileResult();
  }

  FileResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileResult";
  }
  protected:
  explicit FileResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTreeFieldNumber = 1,
    kVersionFieldNumber = 2,
    kPathFieldNumber = 3,
    kBoundsFieldNumber = 4,
  };
  // string tree = 1;
  void clear_tree();
  const std::string& tree() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tree(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tree();
  PROTOBUF_MUST_USE_RESULT std::string* release_tree();
  void set_allocated_tree(std::string* tree);
  private:
  const std::string& _internal_tree() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tree(const std::string& value);
  std::string* _internal_mutable_tree();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string path = 3;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .Bounds bounds = 4;
  bool has_bounds() const;
  private:
  bool _internal_has_bounds() const;
  public:
  void clear_bounds();
  const ::Bounds& bounds() const;
  PROTOBUF_MUST_USE_RESULT ::Bounds* release_bounds();
  ::Bounds* mutable_bounds();
  void set_allocated_bounds(::Bounds* bounds);
  private:
  const ::Bounds& _internal_bounds() const;
  ::Bounds* _internal_mutable_bounds();
  public:
  void unsafe_arena_set_allocated_bounds(
      ::Bounds* bounds);
  ::Bounds* unsafe_arena_release_bounds();

  // @@protoc_insertion_point(class_scope:FileResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tree_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::Bounds* bounds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livegrep_2eproto;
};
// -------------------------------------------------------------------

class SearchStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SearchStats) */ {
 public:
  inline SearchStats() : SearchStats(nullptr) {}
  ~SearchStats() override;
  explicit constexpr SearchStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchStats(const SearchStats& from);
  SearchStats(SearchStats&& from) noexcept
    : SearchStats() {
    *this = ::std::move(from);
  }

  inline SearchStats& operator=(const SearchStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchStats& operator=(SearchStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchStats* internal_default_instance() {
    return reinterpret_cast<const SearchStats*>(
               &_SearchStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SearchStats& a, SearchStats& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchStats* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchStats* New() const final {
    return new SearchStats();
  }

  SearchStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchStats& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SearchStats";
  }
  protected:
  explicit SearchStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SearchStats_ExitReason ExitReason;
  static constexpr ExitReason NONE =
    SearchStats_ExitReason_NONE;
  static constexpr ExitReason TIMEOUT =
    SearchStats_ExitReason_TIMEOUT;
  static constexpr ExitReason MATCH_LIMIT =
    SearchStats_ExitReason_MATCH_LIMIT;
  static inline bool ExitReason_IsValid(int value) {
    return SearchStats_ExitReason_IsValid(value);
  }
  static constexpr ExitReason ExitReason_MIN =
    SearchStats_ExitReason_ExitReason_MIN;
  static constexpr ExitReason ExitReason_MAX =
    SearchStats_ExitReason_ExitReason_MAX;
  static constexpr int ExitReason_ARRAYSIZE =
    SearchStats_ExitReason_ExitReason_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ExitReason_descriptor() {
    return SearchStats_ExitReason_descriptor();
  }
  template<typename T>
  static inline const std::string& ExitReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExitReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExitReason_Name.");
    return SearchStats_ExitReason_Name(enum_t_value);
  }
  static inline bool ExitReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ExitReason* value) {
    return SearchStats_ExitReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRe2TimeFieldNumber = 1,
    kGitTimeFieldNumber = 2,
    kSortTimeFieldNumber = 3,
    kIndexTimeFieldNumber = 4,
    kAnalyzeTimeFieldNumber = 5,
    kTotalTimeFieldNumber = 7,
    kExitReasonFieldNumber = 6,
  };
  // int64 re2_time = 1;
  void clear_re2_time();
  ::PROTOBUF_NAMESPACE_ID::int64 re2_time() const;
  void set_re2_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_re2_time() const;
  void _internal_set_re2_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 git_time = 2;
  void clear_git_time();
  ::PROTOBUF_NAMESPACE_ID::int64 git_time() const;
  void set_git_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_git_time() const;
  void _internal_set_git_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 sort_time = 3;
  void clear_sort_time();
  ::PROTOBUF_NAMESPACE_ID::int64 sort_time() const;
  void set_sort_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sort_time() const;
  void _internal_set_sort_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 index_time = 4;
  void clear_index_time();
  ::PROTOBUF_NAMESPACE_ID::int64 index_time() const;
  void set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index_time() const;
  void _internal_set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 analyze_time = 5;
  void clear_analyze_time();
  ::PROTOBUF_NAMESPACE_ID::int64 analyze_time() const;
  void set_analyze_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_analyze_time() const;
  void _internal_set_analyze_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 total_time = 7;
  void clear_total_time();
  ::PROTOBUF_NAMESPACE_ID::int64 total_time() const;
  void set_total_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total_time() const;
  void _internal_set_total_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .SearchStats.ExitReason exit_reason = 6;
  void clear_exit_reason();
  ::SearchStats_ExitReason exit_reason() const;
  void set_exit_reason(::SearchStats_ExitReason value);
  private:
  ::SearchStats_ExitReason _internal_exit_reason() const;
  void _internal_set_exit_reason(::SearchStats_ExitReason value);
  public:

  // @@protoc_insertion_point(class_scope:SearchStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 re2_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 git_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 sort_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 analyze_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_time_;
  int exit_reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livegrep_2eproto;
};
// -------------------------------------------------------------------

class ServerInfo_Tree final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerInfo.Tree) */ {
 public:
  inline ServerInfo_Tree() : ServerInfo_Tree(nullptr) {}
  ~ServerInfo_Tree() override;
  explicit constexpr ServerInfo_Tree(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfo_Tree(const ServerInfo_Tree& from);
  ServerInfo_Tree(ServerInfo_Tree&& from) noexcept
    : ServerInfo_Tree() {
    *this = ::std::move(from);
  }

  inline ServerInfo_Tree& operator=(const ServerInfo_Tree& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfo_Tree& operator=(ServerInfo_Tree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfo_Tree& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfo_Tree* internal_default_instance() {
    return reinterpret_cast<const ServerInfo_Tree*>(
               &_ServerInfo_Tree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ServerInfo_Tree& a, ServerInfo_Tree& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfo_Tree* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfo_Tree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerInfo_Tree* New() const final {
    return new ServerInfo_Tree();
  }

  ServerInfo_Tree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerInfo_Tree>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfo_Tree& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerInfo_Tree& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfo_Tree* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerInfo.Tree";
  }
  protected:
  explicit ServerInfo_Tree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kMetadataFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .Metadata metadata = 3;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::Metadata& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::Metadata* release_metadata();
  ::Metadata* mutable_metadata();
  void set_allocated_metadata(::Metadata* metadata);
  private:
  const ::Metadata& _internal_metadata() const;
  ::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::Metadata* metadata);
  ::Metadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:ServerInfo.Tree)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::Metadata* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livegrep_2eproto;
};
// -------------------------------------------------------------------

class ServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ServerInfo) */ {
 public:
  inline ServerInfo() : ServerInfo(nullptr) {}
  ~ServerInfo() override;
  explicit constexpr ServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerInfo(const ServerInfo& from);
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerInfo* New() const final {
    return new ServerInfo();
  }

  ServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ServerInfo";
  }
  protected:
  explicit ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ServerInfo_Tree Tree;

  // accessors -------------------------------------------------------

  enum : int {
    kTreesFieldNumber = 2,
    kNameFieldNumber = 1,
    kIndexTimeFieldNumber = 4,
    kHasTagsFieldNumber = 3,
  };
  // repeated .ServerInfo.Tree trees = 2;
  int trees_size() const;
  private:
  int _internal_trees_size() const;
  public:
  void clear_trees();
  ::ServerInfo_Tree* mutable_trees(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerInfo_Tree >*
      mutable_trees();
  private:
  const ::ServerInfo_Tree& _internal_trees(int index) const;
  ::ServerInfo_Tree* _internal_add_trees();
  public:
  const ::ServerInfo_Tree& trees(int index) const;
  ::ServerInfo_Tree* add_trees();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerInfo_Tree >&
      trees() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 index_time = 4;
  void clear_index_time();
  ::PROTOBUF_NAMESPACE_ID::int64 index_time() const;
  void set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index_time() const;
  void _internal_set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool has_tags = 3;
  void clear_has_tags();
  bool has_tags() const;
  void set_has_tags(bool value);
  private:
  bool _internal_has_tags() const;
  void _internal_set_has_tags(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerInfo_Tree > trees_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_time_;
  bool has_tags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livegrep_2eproto;
};
// -------------------------------------------------------------------

class CodeSearchResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CodeSearchResult) */ {
 public:
  inline CodeSearchResult() : CodeSearchResult(nullptr) {}
  ~CodeSearchResult() override;
  explicit constexpr CodeSearchResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CodeSearchResult(const CodeSearchResult& from);
  CodeSearchResult(CodeSearchResult&& from) noexcept
    : CodeSearchResult() {
    *this = ::std::move(from);
  }

  inline CodeSearchResult& operator=(const CodeSearchResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CodeSearchResult& operator=(CodeSearchResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CodeSearchResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const CodeSearchResult* internal_default_instance() {
    return reinterpret_cast<const CodeSearchResult*>(
               &_CodeSearchResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CodeSearchResult& a, CodeSearchResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CodeSearchResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CodeSearchResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CodeSearchResult* New() const final {
    return new CodeSearchResult();
  }

  CodeSearchResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CodeSearchResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CodeSearchResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CodeSearchResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CodeSearchResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CodeSearchResult";
  }
  protected:
  explicit CodeSearchResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kFileResultsFieldNumber = 3,
    kIndexNameFieldNumber = 4,
    kStatsFieldNumber = 1,
    kIndexTimeFieldNumber = 5,
  };
  // repeated .SearchResult results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::SearchResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SearchResult >*
      mutable_results();
  private:
  const ::SearchResult& _internal_results(int index) const;
  ::SearchResult* _internal_add_results();
  public:
  const ::SearchResult& results(int index) const;
  ::SearchResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SearchResult >&
      results() const;

  // repeated .FileResult file_results = 3;
  int file_results_size() const;
  private:
  int _internal_file_results_size() const;
  public:
  void clear_file_results();
  ::FileResult* mutable_file_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FileResult >*
      mutable_file_results();
  private:
  const ::FileResult& _internal_file_results(int index) const;
  ::FileResult* _internal_add_file_results();
  public:
  const ::FileResult& file_results(int index) const;
  ::FileResult* add_file_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FileResult >&
      file_results() const;

  // string index_name = 4;
  void clear_index_name();
  const std::string& index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);
  private:
  const std::string& _internal_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_name(const std::string& value);
  std::string* _internal_mutable_index_name();
  public:

  // .SearchStats stats = 1;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::SearchStats& stats() const;
  PROTOBUF_MUST_USE_RESULT ::SearchStats* release_stats();
  ::SearchStats* mutable_stats();
  void set_allocated_stats(::SearchStats* stats);
  private:
  const ::SearchStats& _internal_stats() const;
  ::SearchStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::SearchStats* stats);
  ::SearchStats* unsafe_arena_release_stats();

  // int64 index_time = 5;
  void clear_index_time();
  ::PROTOBUF_NAMESPACE_ID::int64 index_time() const;
  void set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index_time() const;
  void _internal_set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:CodeSearchResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SearchResult > results_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FileResult > file_results_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
  ::SearchStats* stats_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livegrep_2eproto;
};
// -------------------------------------------------------------------

class InfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:InfoRequest) */ {
 public:
  inline InfoRequest() : InfoRequest(nullptr) {}
  explicit constexpr InfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InfoRequest(const InfoRequest& from);
  InfoRequest(InfoRequest&& from) noexcept
    : InfoRequest() {
    *this = ::std::move(from);
  }

  inline InfoRequest& operator=(const InfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoRequest& operator=(InfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoRequest* internal_default_instance() {
    return reinterpret_cast<const InfoRequest*>(
               &_InfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InfoRequest& a, InfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InfoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InfoRequest* New() const final {
    return new InfoRequest();
  }

  InfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InfoRequest";
  }
  protected:
  explicit InfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:InfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livegrep_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit constexpr Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return new Empty();
  }

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_livegrep_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Query

// string line = 1;
inline void Query::clear_line() {
  line_.ClearToEmpty();
}
inline const std::string& Query::line() const {
  // @@protoc_insertion_point(field_get:Query.line)
  return _internal_line();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Query::set_line(ArgT0&& arg0, ArgT... args) {
 
 line_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Query.line)
}
inline std::string* Query::mutable_line() {
  std::string* _s = _internal_mutable_line();
  // @@protoc_insertion_point(field_mutable:Query.line)
  return _s;
}
inline const std::string& Query::_internal_line() const {
  return line_.Get();
}
inline void Query::_internal_set_line(const std::string& value) {
  
  line_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Query::_internal_mutable_line() {
  
  return line_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Query::release_line() {
  // @@protoc_insertion_point(field_release:Query.line)
  return line_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Query::set_allocated_line(std::string* line) {
  if (line != nullptr) {
    
  } else {
    
  }
  line_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), line,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Query.line)
}

// repeated string file = 2;
inline int Query::_internal_file_size() const {
  return file_.size();
}
inline int Query::file_size() const {
  return _internal_file_size();
}
inline void Query::clear_file() {
  file_.Clear();
}
inline std::string* Query::add_file() {
  std::string* _s = _internal_add_file();
  // @@protoc_insertion_point(field_add_mutable:Query.file)
  return _s;
}
inline const std::string& Query::_internal_file(int index) const {
  return file_.Get(index);
}
inline const std::string& Query::file(int index) const {
  // @@protoc_insertion_point(field_get:Query.file)
  return _internal_file(index);
}
inline std::string* Query::mutable_file(int index) {
  // @@protoc_insertion_point(field_mutable:Query.file)
  return file_.Mutable(index);
}
inline void Query::set_file(int index, const std::string& value) {
  file_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Query.file)
}
inline void Query::set_file(int index, std::string&& value) {
  file_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Query.file)
}
inline void Query::set_file(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  file_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Query.file)
}
inline void Query::set_file(int index, const char* value, size_t size) {
  file_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Query.file)
}
inline std::string* Query::_internal_add_file() {
  return file_.Add();
}
inline void Query::add_file(const std::string& value) {
  file_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Query.file)
}
inline void Query::add_file(std::string&& value) {
  file_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Query.file)
}
inline void Query::add_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  file_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Query.file)
}
inline void Query::add_file(const char* value, size_t size) {
  file_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Query.file)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Query::file() const {
  // @@protoc_insertion_point(field_list:Query.file)
  return file_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Query::mutable_file() {
  // @@protoc_insertion_point(field_mutable_list:Query.file)
  return &file_;
}

// string repo = 3;
inline void Query::clear_repo() {
  repo_.ClearToEmpty();
}
inline const std::string& Query::repo() const {
  // @@protoc_insertion_point(field_get:Query.repo)
  return _internal_repo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Query::set_repo(ArgT0&& arg0, ArgT... args) {
 
 repo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Query.repo)
}
inline std::string* Query::mutable_repo() {
  std::string* _s = _internal_mutable_repo();
  // @@protoc_insertion_point(field_mutable:Query.repo)
  return _s;
}
inline const std::string& Query::_internal_repo() const {
  return repo_.Get();
}
inline void Query::_internal_set_repo(const std::string& value) {
  
  repo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Query::_internal_mutable_repo() {
  
  return repo_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Query::release_repo() {
  // @@protoc_insertion_point(field_release:Query.repo)
  return repo_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Query::set_allocated_repo(std::string* repo) {
  if (repo != nullptr) {
    
  } else {
    
  }
  repo_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), repo,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Query.repo)
}

// string tags = 4;
inline void Query::clear_tags() {
  tags_.ClearToEmpty();
}
inline const std::string& Query::tags() const {
  // @@protoc_insertion_point(field_get:Query.tags)
  return _internal_tags();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Query::set_tags(ArgT0&& arg0, ArgT... args) {
 
 tags_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Query.tags)
}
inline std::string* Query::mutable_tags() {
  std::string* _s = _internal_mutable_tags();
  // @@protoc_insertion_point(field_mutable:Query.tags)
  return _s;
}
inline const std::string& Query::_internal_tags() const {
  return tags_.Get();
}
inline void Query::_internal_set_tags(const std::string& value) {
  
  tags_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Query::_internal_mutable_tags() {
  
  return tags_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Query::release_tags() {
  // @@protoc_insertion_point(field_release:Query.tags)
  return tags_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Query::set_allocated_tags(std::string* tags) {
  if (tags != nullptr) {
    
  } else {
    
  }
  tags_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tags,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Query.tags)
}

// bool fold_case = 5;
inline void Query::clear_fold_case() {
  fold_case_ = false;
}
inline bool Query::_internal_fold_case() const {
  return fold_case_;
}
inline bool Query::fold_case() const {
  // @@protoc_insertion_point(field_get:Query.fold_case)
  return _internal_fold_case();
}
inline void Query::_internal_set_fold_case(bool value) {
  
  fold_case_ = value;
}
inline void Query::set_fold_case(bool value) {
  _internal_set_fold_case(value);
  // @@protoc_insertion_point(field_set:Query.fold_case)
}

// repeated string not_file = 6;
inline int Query::_internal_not_file_size() const {
  return not_file_.size();
}
inline int Query::not_file_size() const {
  return _internal_not_file_size();
}
inline void Query::clear_not_file() {
  not_file_.Clear();
}
inline std::string* Query::add_not_file() {
  std::string* _s = _internal_add_not_file();
  // @@protoc_insertion_point(field_add_mutable:Query.not_file)
  return _s;
}
inline const std::string& Query::_internal_not_file(int index) const {
  return not_file_.Get(index);
}
inline const std::string& Query::not_file(int index) const {
  // @@protoc_insertion_point(field_get:Query.not_file)
  return _internal_not_file(index);
}
inline std::string* Query::mutable_not_file(int index) {
  // @@protoc_insertion_point(field_mutable:Query.not_file)
  return not_file_.Mutable(index);
}
inline void Query::set_not_file(int index, const std::string& value) {
  not_file_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Query.not_file)
}
inline void Query::set_not_file(int index, std::string&& value) {
  not_file_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Query.not_file)
}
inline void Query::set_not_file(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  not_file_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Query.not_file)
}
inline void Query::set_not_file(int index, const char* value, size_t size) {
  not_file_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Query.not_file)
}
inline std::string* Query::_internal_add_not_file() {
  return not_file_.Add();
}
inline void Query::add_not_file(const std::string& value) {
  not_file_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Query.not_file)
}
inline void Query::add_not_file(std::string&& value) {
  not_file_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Query.not_file)
}
inline void Query::add_not_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  not_file_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Query.not_file)
}
inline void Query::add_not_file(const char* value, size_t size) {
  not_file_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Query.not_file)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Query::not_file() const {
  // @@protoc_insertion_point(field_list:Query.not_file)
  return not_file_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Query::mutable_not_file() {
  // @@protoc_insertion_point(field_mutable_list:Query.not_file)
  return &not_file_;
}

// string not_repo = 7;
inline void Query::clear_not_repo() {
  not_repo_.ClearToEmpty();
}
inline const std::string& Query::not_repo() const {
  // @@protoc_insertion_point(field_get:Query.not_repo)
  return _internal_not_repo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Query::set_not_repo(ArgT0&& arg0, ArgT... args) {
 
 not_repo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Query.not_repo)
}
inline std::string* Query::mutable_not_repo() {
  std::string* _s = _internal_mutable_not_repo();
  // @@protoc_insertion_point(field_mutable:Query.not_repo)
  return _s;
}
inline const std::string& Query::_internal_not_repo() const {
  return not_repo_.Get();
}
inline void Query::_internal_set_not_repo(const std::string& value) {
  
  not_repo_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Query::_internal_mutable_not_repo() {
  
  return not_repo_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Query::release_not_repo() {
  // @@protoc_insertion_point(field_release:Query.not_repo)
  return not_repo_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Query::set_allocated_not_repo(std::string* not_repo) {
  if (not_repo != nullptr) {
    
  } else {
    
  }
  not_repo_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_repo,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Query.not_repo)
}

// string not_tags = 8;
inline void Query::clear_not_tags() {
  not_tags_.ClearToEmpty();
}
inline const std::string& Query::not_tags() const {
  // @@protoc_insertion_point(field_get:Query.not_tags)
  return _internal_not_tags();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Query::set_not_tags(ArgT0&& arg0, ArgT... args) {
 
 not_tags_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Query.not_tags)
}
inline std::string* Query::mutable_not_tags() {
  std::string* _s = _internal_mutable_not_tags();
  // @@protoc_insertion_point(field_mutable:Query.not_tags)
  return _s;
}
inline const std::string& Query::_internal_not_tags() const {
  return not_tags_.Get();
}
inline void Query::_internal_set_not_tags(const std::string& value) {
  
  not_tags_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Query::_internal_mutable_not_tags() {
  
  return not_tags_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Query::release_not_tags() {
  // @@protoc_insertion_point(field_release:Query.not_tags)
  return not_tags_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Query::set_allocated_not_tags(std::string* not_tags) {
  if (not_tags != nullptr) {
    
  } else {
    
  }
  not_tags_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_tags,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:Query.not_tags)
}

// int32 max_matches = 9;
inline void Query::clear_max_matches() {
  max_matches_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Query::_internal_max_matches() const {
  return max_matches_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Query::max_matches() const {
  // @@protoc_insertion_point(field_get:Query.max_matches)
  return _internal_max_matches();
}
inline void Query::_internal_set_max_matches(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_matches_ = value;
}
inline void Query::set_max_matches(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_matches(value);
  // @@protoc_insertion_point(field_set:Query.max_matches)
}

// bool filename_only = 10;
inline void Query::clear_filename_only() {
  filename_only_ = false;
}
inline bool Query::_internal_filename_only() const {
  return filename_only_;
}
inline bool Query::filename_only() const {
  // @@protoc_insertion_point(field_get:Query.filename_only)
  return _internal_filename_only();
}
inline void Query::_internal_set_filename_only(bool value) {
  
  filename_only_ = value;
}
inline void Query::set_filename_only(bool value) {
  _internal_set_filename_only(value);
  // @@protoc_insertion_point(field_set:Query.filename_only)
}

// int32 context_lines = 11;
inline void Query::clear_context_lines() {
  context_lines_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Query::_internal_context_lines() const {
  return context_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Query::context_lines() const {
  // @@protoc_insertion_point(field_get:Query.context_lines)
  return _internal_context_lines();
}
inline void Query::_internal_set_context_lines(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  context_lines_ = value;
}
inline void Query::set_context_lines(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_context_lines(value);
  // @@protoc_insertion_point(field_set:Query.context_lines)
}

// -------------------------------------------------------------------

// Bounds

// int32 left = 1;
inline void Bounds::clear_left() {
  left_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bounds::_internal_left() const {
  return left_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bounds::left() const {
  // @@protoc_insertion_point(field_get:Bounds.left)
  return _internal_left();
}
inline void Bounds::_internal_set_left(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  left_ = value;
}
inline void Bounds::set_left(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:Bounds.left)
}

// int32 right = 2;
inline void Bounds::clear_right() {
  right_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bounds::_internal_right() const {
  return right_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Bounds::right() const {
  // @@protoc_insertion_point(field_get:Bounds.right)
  return _internal_right();
}
inline void Bounds::_internal_set_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  right_ = value;
}
inline void Bounds::set_right(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:Bounds.right)
}

// -------------------------------------------------------------------

// SearchResult

// string tree = 1;
inline void SearchResult::clear_tree() {
  tree_.ClearToEmpty();
}
inline const std::string& SearchResult::tree() const {
  // @@protoc_insertion_point(field_get:SearchResult.tree)
  return _internal_tree();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchResult::set_tree(ArgT0&& arg0, ArgT... args) {
 
 tree_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SearchResult.tree)
}
inline std::string* SearchResult::mutable_tree() {
  std::string* _s = _internal_mutable_tree();
  // @@protoc_insertion_point(field_mutable:SearchResult.tree)
  return _s;
}
inline const std::string& SearchResult::_internal_tree() const {
  return tree_.Get();
}
inline void SearchResult::_internal_set_tree(const std::string& value) {
  
  tree_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SearchResult::_internal_mutable_tree() {
  
  return tree_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SearchResult::release_tree() {
  // @@protoc_insertion_point(field_release:SearchResult.tree)
  return tree_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SearchResult::set_allocated_tree(std::string* tree) {
  if (tree != nullptr) {
    
  } else {
    
  }
  tree_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tree,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SearchResult.tree)
}

// string version = 2;
inline void SearchResult::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& SearchResult::version() const {
  // @@protoc_insertion_point(field_get:SearchResult.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchResult::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SearchResult.version)
}
inline std::string* SearchResult::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:SearchResult.version)
  return _s;
}
inline const std::string& SearchResult::_internal_version() const {
  return version_.Get();
}
inline void SearchResult::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SearchResult::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SearchResult::release_version() {
  // @@protoc_insertion_point(field_release:SearchResult.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SearchResult::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SearchResult.version)
}

// string path = 3;
inline void SearchResult::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& SearchResult::path() const {
  // @@protoc_insertion_point(field_get:SearchResult.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchResult::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SearchResult.path)
}
inline std::string* SearchResult::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SearchResult.path)
  return _s;
}
inline const std::string& SearchResult::_internal_path() const {
  return path_.Get();
}
inline void SearchResult::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SearchResult::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SearchResult::release_path() {
  // @@protoc_insertion_point(field_release:SearchResult.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SearchResult::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SearchResult.path)
}

// int64 line_number = 4;
inline void SearchResult::clear_line_number() {
  line_number_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchResult::_internal_line_number() const {
  return line_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchResult::line_number() const {
  // @@protoc_insertion_point(field_get:SearchResult.line_number)
  return _internal_line_number();
}
inline void SearchResult::_internal_set_line_number(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  line_number_ = value;
}
inline void SearchResult::set_line_number(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_line_number(value);
  // @@protoc_insertion_point(field_set:SearchResult.line_number)
}

// repeated string context_before = 5;
inline int SearchResult::_internal_context_before_size() const {
  return context_before_.size();
}
inline int SearchResult::context_before_size() const {
  return _internal_context_before_size();
}
inline void SearchResult::clear_context_before() {
  context_before_.Clear();
}
inline std::string* SearchResult::add_context_before() {
  std::string* _s = _internal_add_context_before();
  // @@protoc_insertion_point(field_add_mutable:SearchResult.context_before)
  return _s;
}
inline const std::string& SearchResult::_internal_context_before(int index) const {
  return context_before_.Get(index);
}
inline const std::string& SearchResult::context_before(int index) const {
  // @@protoc_insertion_point(field_get:SearchResult.context_before)
  return _internal_context_before(index);
}
inline std::string* SearchResult::mutable_context_before(int index) {
  // @@protoc_insertion_point(field_mutable:SearchResult.context_before)
  return context_before_.Mutable(index);
}
inline void SearchResult::set_context_before(int index, const std::string& value) {
  context_before_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SearchResult.context_before)
}
inline void SearchResult::set_context_before(int index, std::string&& value) {
  context_before_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SearchResult.context_before)
}
inline void SearchResult::set_context_before(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  context_before_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SearchResult.context_before)
}
inline void SearchResult::set_context_before(int index, const char* value, size_t size) {
  context_before_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SearchResult.context_before)
}
inline std::string* SearchResult::_internal_add_context_before() {
  return context_before_.Add();
}
inline void SearchResult::add_context_before(const std::string& value) {
  context_before_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SearchResult.context_before)
}
inline void SearchResult::add_context_before(std::string&& value) {
  context_before_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SearchResult.context_before)
}
inline void SearchResult::add_context_before(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  context_before_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SearchResult.context_before)
}
inline void SearchResult::add_context_before(const char* value, size_t size) {
  context_before_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SearchResult.context_before)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchResult::context_before() const {
  // @@protoc_insertion_point(field_list:SearchResult.context_before)
  return context_before_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchResult::mutable_context_before() {
  // @@protoc_insertion_point(field_mutable_list:SearchResult.context_before)
  return &context_before_;
}

// repeated string context_after = 6;
inline int SearchResult::_internal_context_after_size() const {
  return context_after_.size();
}
inline int SearchResult::context_after_size() const {
  return _internal_context_after_size();
}
inline void SearchResult::clear_context_after() {
  context_after_.Clear();
}
inline std::string* SearchResult::add_context_after() {
  std::string* _s = _internal_add_context_after();
  // @@protoc_insertion_point(field_add_mutable:SearchResult.context_after)
  return _s;
}
inline const std::string& SearchResult::_internal_context_after(int index) const {
  return context_after_.Get(index);
}
inline const std::string& SearchResult::context_after(int index) const {
  // @@protoc_insertion_point(field_get:SearchResult.context_after)
  return _internal_context_after(index);
}
inline std::string* SearchResult::mutable_context_after(int index) {
  // @@protoc_insertion_point(field_mutable:SearchResult.context_after)
  return context_after_.Mutable(index);
}
inline void SearchResult::set_context_after(int index, const std::string& value) {
  context_after_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SearchResult.context_after)
}
inline void SearchResult::set_context_after(int index, std::string&& value) {
  context_after_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SearchResult.context_after)
}
inline void SearchResult::set_context_after(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  context_after_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SearchResult.context_after)
}
inline void SearchResult::set_context_after(int index, const char* value, size_t size) {
  context_after_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SearchResult.context_after)
}
inline std::string* SearchResult::_internal_add_context_after() {
  return context_after_.Add();
}
inline void SearchResult::add_context_after(const std::string& value) {
  context_after_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SearchResult.context_after)
}
inline void SearchResult::add_context_after(std::string&& value) {
  context_after_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SearchResult.context_after)
}
inline void SearchResult::add_context_after(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  context_after_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SearchResult.context_after)
}
inline void SearchResult::add_context_after(const char* value, size_t size) {
  context_after_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SearchResult.context_after)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchResult::context_after() const {
  // @@protoc_insertion_point(field_list:SearchResult.context_after)
  return context_after_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchResult::mutable_context_after() {
  // @@protoc_insertion_point(field_mutable_list:SearchResult.context_after)
  return &context_after_;
}

// .Bounds bounds = 7;
inline bool SearchResult::_internal_has_bounds() const {
  return this != internal_default_instance() && bounds_ != nullptr;
}
inline bool SearchResult::has_bounds() const {
  return _internal_has_bounds();
}
inline void SearchResult::clear_bounds() {
  if (GetArenaForAllocation() == nullptr && bounds_ != nullptr) {
    delete bounds_;
  }
  bounds_ = nullptr;
}
inline const ::Bounds& SearchResult::_internal_bounds() const {
  const ::Bounds* p = bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::Bounds&>(
      ::_Bounds_default_instance_);
}
inline const ::Bounds& SearchResult::bounds() const {
  // @@protoc_insertion_point(field_get:SearchResult.bounds)
  return _internal_bounds();
}
inline void SearchResult::unsafe_arena_set_allocated_bounds(
    ::Bounds* bounds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bounds_);
  }
  bounds_ = bounds;
  if (bounds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SearchResult.bounds)
}
inline ::Bounds* SearchResult::release_bounds() {
  
  ::Bounds* temp = bounds_;
  bounds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Bounds* SearchResult::unsafe_arena_release_bounds() {
  // @@protoc_insertion_point(field_release:SearchResult.bounds)
  
  ::Bounds* temp = bounds_;
  bounds_ = nullptr;
  return temp;
}
inline ::Bounds* SearchResult::_internal_mutable_bounds() {
  
  if (bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::Bounds>(GetArenaForAllocation());
    bounds_ = p;
  }
  return bounds_;
}
inline ::Bounds* SearchResult::mutable_bounds() {
  ::Bounds* _msg = _internal_mutable_bounds();
  // @@protoc_insertion_point(field_mutable:SearchResult.bounds)
  return _msg;
}
inline void SearchResult::set_allocated_bounds(::Bounds* bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bounds_;
  }
  if (bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Bounds>::GetOwningArena(bounds);
    if (message_arena != submessage_arena) {
      bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bounds, submessage_arena);
    }
    
  } else {
    
  }
  bounds_ = bounds;
  // @@protoc_insertion_point(field_set_allocated:SearchResult.bounds)
}

// string line = 8;
inline void SearchResult::clear_line() {
  line_.ClearToEmpty();
}
inline const std::string& SearchResult::line() const {
  // @@protoc_insertion_point(field_get:SearchResult.line)
  return _internal_line();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchResult::set_line(ArgT0&& arg0, ArgT... args) {
 
 line_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SearchResult.line)
}
inline std::string* SearchResult::mutable_line() {
  std::string* _s = _internal_mutable_line();
  // @@protoc_insertion_point(field_mutable:SearchResult.line)
  return _s;
}
inline const std::string& SearchResult::_internal_line() const {
  return line_.Get();
}
inline void SearchResult::_internal_set_line(const std::string& value) {
  
  line_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SearchResult::_internal_mutable_line() {
  
  return line_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SearchResult::release_line() {
  // @@protoc_insertion_point(field_release:SearchResult.line)
  return line_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SearchResult::set_allocated_line(std::string* line) {
  if (line != nullptr) {
    
  } else {
    
  }
  line_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), line,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SearchResult.line)
}

// -------------------------------------------------------------------

// FileResult

// string tree = 1;
inline void FileResult::clear_tree() {
  tree_.ClearToEmpty();
}
inline const std::string& FileResult::tree() const {
  // @@protoc_insertion_point(field_get:FileResult.tree)
  return _internal_tree();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileResult::set_tree(ArgT0&& arg0, ArgT... args) {
 
 tree_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileResult.tree)
}
inline std::string* FileResult::mutable_tree() {
  std::string* _s = _internal_mutable_tree();
  // @@protoc_insertion_point(field_mutable:FileResult.tree)
  return _s;
}
inline const std::string& FileResult::_internal_tree() const {
  return tree_.Get();
}
inline void FileResult::_internal_set_tree(const std::string& value) {
  
  tree_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileResult::_internal_mutable_tree() {
  
  return tree_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileResult::release_tree() {
  // @@protoc_insertion_point(field_release:FileResult.tree)
  return tree_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileResult::set_allocated_tree(std::string* tree) {
  if (tree != nullptr) {
    
  } else {
    
  }
  tree_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tree,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FileResult.tree)
}

// string version = 2;
inline void FileResult::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& FileResult::version() const {
  // @@protoc_insertion_point(field_get:FileResult.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileResult::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileResult.version)
}
inline std::string* FileResult::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:FileResult.version)
  return _s;
}
inline const std::string& FileResult::_internal_version() const {
  return version_.Get();
}
inline void FileResult::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileResult::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileResult::release_version() {
  // @@protoc_insertion_point(field_release:FileResult.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileResult::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FileResult.version)
}

// string path = 3;
inline void FileResult::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& FileResult::path() const {
  // @@protoc_insertion_point(field_get:FileResult.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileResult::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileResult.path)
}
inline std::string* FileResult::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:FileResult.path)
  return _s;
}
inline const std::string& FileResult::_internal_path() const {
  return path_.Get();
}
inline void FileResult::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileResult::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileResult::release_path() {
  // @@protoc_insertion_point(field_release:FileResult.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileResult::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FileResult.path)
}

// .Bounds bounds = 4;
inline bool FileResult::_internal_has_bounds() const {
  return this != internal_default_instance() && bounds_ != nullptr;
}
inline bool FileResult::has_bounds() const {
  return _internal_has_bounds();
}
inline void FileResult::clear_bounds() {
  if (GetArenaForAllocation() == nullptr && bounds_ != nullptr) {
    delete bounds_;
  }
  bounds_ = nullptr;
}
inline const ::Bounds& FileResult::_internal_bounds() const {
  const ::Bounds* p = bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::Bounds&>(
      ::_Bounds_default_instance_);
}
inline const ::Bounds& FileResult::bounds() const {
  // @@protoc_insertion_point(field_get:FileResult.bounds)
  return _internal_bounds();
}
inline void FileResult::unsafe_arena_set_allocated_bounds(
    ::Bounds* bounds) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bounds_);
  }
  bounds_ = bounds;
  if (bounds) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FileResult.bounds)
}
inline ::Bounds* FileResult::release_bounds() {
  
  ::Bounds* temp = bounds_;
  bounds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Bounds* FileResult::unsafe_arena_release_bounds() {
  // @@protoc_insertion_point(field_release:FileResult.bounds)
  
  ::Bounds* temp = bounds_;
  bounds_ = nullptr;
  return temp;
}
inline ::Bounds* FileResult::_internal_mutable_bounds() {
  
  if (bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::Bounds>(GetArenaForAllocation());
    bounds_ = p;
  }
  return bounds_;
}
inline ::Bounds* FileResult::mutable_bounds() {
  ::Bounds* _msg = _internal_mutable_bounds();
  // @@protoc_insertion_point(field_mutable:FileResult.bounds)
  return _msg;
}
inline void FileResult::set_allocated_bounds(::Bounds* bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bounds_;
  }
  if (bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Bounds>::GetOwningArena(bounds);
    if (message_arena != submessage_arena) {
      bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bounds, submessage_arena);
    }
    
  } else {
    
  }
  bounds_ = bounds;
  // @@protoc_insertion_point(field_set_allocated:FileResult.bounds)
}

// -------------------------------------------------------------------

// SearchStats

// int64 re2_time = 1;
inline void SearchStats::clear_re2_time() {
  re2_time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::_internal_re2_time() const {
  return re2_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::re2_time() const {
  // @@protoc_insertion_point(field_get:SearchStats.re2_time)
  return _internal_re2_time();
}
inline void SearchStats::_internal_set_re2_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  re2_time_ = value;
}
inline void SearchStats::set_re2_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_re2_time(value);
  // @@protoc_insertion_point(field_set:SearchStats.re2_time)
}

// int64 git_time = 2;
inline void SearchStats::clear_git_time() {
  git_time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::_internal_git_time() const {
  return git_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::git_time() const {
  // @@protoc_insertion_point(field_get:SearchStats.git_time)
  return _internal_git_time();
}
inline void SearchStats::_internal_set_git_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  git_time_ = value;
}
inline void SearchStats::set_git_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_git_time(value);
  // @@protoc_insertion_point(field_set:SearchStats.git_time)
}

// int64 sort_time = 3;
inline void SearchStats::clear_sort_time() {
  sort_time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::_internal_sort_time() const {
  return sort_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::sort_time() const {
  // @@protoc_insertion_point(field_get:SearchStats.sort_time)
  return _internal_sort_time();
}
inline void SearchStats::_internal_set_sort_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  sort_time_ = value;
}
inline void SearchStats::set_sort_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sort_time(value);
  // @@protoc_insertion_point(field_set:SearchStats.sort_time)
}

// int64 index_time = 4;
inline void SearchStats::clear_index_time() {
  index_time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::_internal_index_time() const {
  return index_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::index_time() const {
  // @@protoc_insertion_point(field_get:SearchStats.index_time)
  return _internal_index_time();
}
inline void SearchStats::_internal_set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  index_time_ = value;
}
inline void SearchStats::set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index_time(value);
  // @@protoc_insertion_point(field_set:SearchStats.index_time)
}

// int64 analyze_time = 5;
inline void SearchStats::clear_analyze_time() {
  analyze_time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::_internal_analyze_time() const {
  return analyze_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::analyze_time() const {
  // @@protoc_insertion_point(field_get:SearchStats.analyze_time)
  return _internal_analyze_time();
}
inline void SearchStats::_internal_set_analyze_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  analyze_time_ = value;
}
inline void SearchStats::set_analyze_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_analyze_time(value);
  // @@protoc_insertion_point(field_set:SearchStats.analyze_time)
}

// int64 total_time = 7;
inline void SearchStats::clear_total_time() {
  total_time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::_internal_total_time() const {
  return total_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SearchStats::total_time() const {
  // @@protoc_insertion_point(field_get:SearchStats.total_time)
  return _internal_total_time();
}
inline void SearchStats::_internal_set_total_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  total_time_ = value;
}
inline void SearchStats::set_total_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total_time(value);
  // @@protoc_insertion_point(field_set:SearchStats.total_time)
}

// .SearchStats.ExitReason exit_reason = 6;
inline void SearchStats::clear_exit_reason() {
  exit_reason_ = 0;
}
inline ::SearchStats_ExitReason SearchStats::_internal_exit_reason() const {
  return static_cast< ::SearchStats_ExitReason >(exit_reason_);
}
inline ::SearchStats_ExitReason SearchStats::exit_reason() const {
  // @@protoc_insertion_point(field_get:SearchStats.exit_reason)
  return _internal_exit_reason();
}
inline void SearchStats::_internal_set_exit_reason(::SearchStats_ExitReason value) {
  
  exit_reason_ = value;
}
inline void SearchStats::set_exit_reason(::SearchStats_ExitReason value) {
  _internal_set_exit_reason(value);
  // @@protoc_insertion_point(field_set:SearchStats.exit_reason)
}

// -------------------------------------------------------------------

// ServerInfo_Tree

// string name = 1;
inline void ServerInfo_Tree::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ServerInfo_Tree::name() const {
  // @@protoc_insertion_point(field_get:ServerInfo.Tree.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo_Tree::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerInfo.Tree.name)
}
inline std::string* ServerInfo_Tree::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ServerInfo.Tree.name)
  return _s;
}
inline const std::string& ServerInfo_Tree::_internal_name() const {
  return name_.Get();
}
inline void ServerInfo_Tree::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerInfo_Tree::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerInfo_Tree::release_name() {
  // @@protoc_insertion_point(field_release:ServerInfo.Tree.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServerInfo_Tree::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ServerInfo.Tree.name)
}

// string version = 2;
inline void ServerInfo_Tree::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& ServerInfo_Tree::version() const {
  // @@protoc_insertion_point(field_get:ServerInfo.Tree.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo_Tree::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerInfo.Tree.version)
}
inline std::string* ServerInfo_Tree::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ServerInfo.Tree.version)
  return _s;
}
inline const std::string& ServerInfo_Tree::_internal_version() const {
  return version_.Get();
}
inline void ServerInfo_Tree::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerInfo_Tree::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerInfo_Tree::release_version() {
  // @@protoc_insertion_point(field_release:ServerInfo.Tree.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServerInfo_Tree::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ServerInfo.Tree.version)
}

// .Metadata metadata = 3;
inline bool ServerInfo_Tree::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool ServerInfo_Tree::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::Metadata& ServerInfo_Tree::_internal_metadata() const {
  const ::Metadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::Metadata&>(
      ::_Metadata_default_instance_);
}
inline const ::Metadata& ServerInfo_Tree::metadata() const {
  // @@protoc_insertion_point(field_get:ServerInfo.Tree.metadata)
  return _internal_metadata();
}
inline void ServerInfo_Tree::unsafe_arena_set_allocated_metadata(
    ::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerInfo.Tree.metadata)
}
inline ::Metadata* ServerInfo_Tree::release_metadata() {
  
  ::Metadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Metadata* ServerInfo_Tree::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:ServerInfo.Tree.metadata)
  
  ::Metadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::Metadata* ServerInfo_Tree::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::Metadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::Metadata* ServerInfo_Tree::mutable_metadata() {
  ::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:ServerInfo.Tree.metadata)
  return _msg;
}
inline void ServerInfo_Tree::set_allocated_metadata(::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:ServerInfo.Tree.metadata)
}

// -------------------------------------------------------------------

// ServerInfo

// string name = 1;
inline void ServerInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ServerInfo::name() const {
  // @@protoc_insertion_point(field_get:ServerInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ServerInfo.name)
}
inline std::string* ServerInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ServerInfo.name)
  return _s;
}
inline const std::string& ServerInfo::_internal_name() const {
  return name_.Get();
}
inline void ServerInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServerInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServerInfo::release_name() {
  // @@protoc_insertion_point(field_release:ServerInfo.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:ServerInfo.name)
}

// repeated .ServerInfo.Tree trees = 2;
inline int ServerInfo::_internal_trees_size() const {
  return trees_.size();
}
inline int ServerInfo::trees_size() const {
  return _internal_trees_size();
}
inline void ServerInfo::clear_trees() {
  trees_.Clear();
}
inline ::ServerInfo_Tree* ServerInfo::mutable_trees(int index) {
  // @@protoc_insertion_point(field_mutable:ServerInfo.trees)
  return trees_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerInfo_Tree >*
ServerInfo::mutable_trees() {
  // @@protoc_insertion_point(field_mutable_list:ServerInfo.trees)
  return &trees_;
}
inline const ::ServerInfo_Tree& ServerInfo::_internal_trees(int index) const {
  return trees_.Get(index);
}
inline const ::ServerInfo_Tree& ServerInfo::trees(int index) const {
  // @@protoc_insertion_point(field_get:ServerInfo.trees)
  return _internal_trees(index);
}
inline ::ServerInfo_Tree* ServerInfo::_internal_add_trees() {
  return trees_.Add();
}
inline ::ServerInfo_Tree* ServerInfo::add_trees() {
  ::ServerInfo_Tree* _add = _internal_add_trees();
  // @@protoc_insertion_point(field_add:ServerInfo.trees)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ServerInfo_Tree >&
ServerInfo::trees() const {
  // @@protoc_insertion_point(field_list:ServerInfo.trees)
  return trees_;
}

// bool has_tags = 3;
inline void ServerInfo::clear_has_tags() {
  has_tags_ = false;
}
inline bool ServerInfo::_internal_has_tags() const {
  return has_tags_;
}
inline bool ServerInfo::has_tags() const {
  // @@protoc_insertion_point(field_get:ServerInfo.has_tags)
  return _internal_has_tags();
}
inline void ServerInfo::_internal_set_has_tags(bool value) {
  
  has_tags_ = value;
}
inline void ServerInfo::set_has_tags(bool value) {
  _internal_set_has_tags(value);
  // @@protoc_insertion_point(field_set:ServerInfo.has_tags)
}

// int64 index_time = 4;
inline void ServerInfo::clear_index_time() {
  index_time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ServerInfo::_internal_index_time() const {
  return index_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ServerInfo::index_time() const {
  // @@protoc_insertion_point(field_get:ServerInfo.index_time)
  return _internal_index_time();
}
inline void ServerInfo::_internal_set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  index_time_ = value;
}
inline void ServerInfo::set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index_time(value);
  // @@protoc_insertion_point(field_set:ServerInfo.index_time)
}

// -------------------------------------------------------------------

// CodeSearchResult

// .SearchStats stats = 1;
inline bool CodeSearchResult::_internal_has_stats() const {
  return this != internal_default_instance() && stats_ != nullptr;
}
inline bool CodeSearchResult::has_stats() const {
  return _internal_has_stats();
}
inline void CodeSearchResult::clear_stats() {
  if (GetArenaForAllocation() == nullptr && stats_ != nullptr) {
    delete stats_;
  }
  stats_ = nullptr;
}
inline const ::SearchStats& CodeSearchResult::_internal_stats() const {
  const ::SearchStats* p = stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::SearchStats&>(
      ::_SearchStats_default_instance_);
}
inline const ::SearchStats& CodeSearchResult::stats() const {
  // @@protoc_insertion_point(field_get:CodeSearchResult.stats)
  return _internal_stats();
}
inline void CodeSearchResult::unsafe_arena_set_allocated_stats(
    ::SearchStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats_);
  }
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CodeSearchResult.stats)
}
inline ::SearchStats* CodeSearchResult::release_stats() {
  
  ::SearchStats* temp = stats_;
  stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SearchStats* CodeSearchResult::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:CodeSearchResult.stats)
  
  ::SearchStats* temp = stats_;
  stats_ = nullptr;
  return temp;
}
inline ::SearchStats* CodeSearchResult::_internal_mutable_stats() {
  
  if (stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::SearchStats>(GetArenaForAllocation());
    stats_ = p;
  }
  return stats_;
}
inline ::SearchStats* CodeSearchResult::mutable_stats() {
  ::SearchStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:CodeSearchResult.stats)
  return _msg;
}
inline void CodeSearchResult::set_allocated_stats(::SearchStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stats_;
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SearchStats>::GetOwningArena(stats);
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:CodeSearchResult.stats)
}

// repeated .SearchResult results = 2;
inline int CodeSearchResult::_internal_results_size() const {
  return results_.size();
}
inline int CodeSearchResult::results_size() const {
  return _internal_results_size();
}
inline void CodeSearchResult::clear_results() {
  results_.Clear();
}
inline ::SearchResult* CodeSearchResult::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CodeSearchResult.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SearchResult >*
CodeSearchResult::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CodeSearchResult.results)
  return &results_;
}
inline const ::SearchResult& CodeSearchResult::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::SearchResult& CodeSearchResult::results(int index) const {
  // @@protoc_insertion_point(field_get:CodeSearchResult.results)
  return _internal_results(index);
}
inline ::SearchResult* CodeSearchResult::_internal_add_results() {
  return results_.Add();
}
inline ::SearchResult* CodeSearchResult::add_results() {
  ::SearchResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CodeSearchResult.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SearchResult >&
CodeSearchResult::results() const {
  // @@protoc_insertion_point(field_list:CodeSearchResult.results)
  return results_;
}

// repeated .FileResult file_results = 3;
inline int CodeSearchResult::_internal_file_results_size() const {
  return file_results_.size();
}
inline int CodeSearchResult::file_results_size() const {
  return _internal_file_results_size();
}
inline void CodeSearchResult::clear_file_results() {
  file_results_.Clear();
}
inline ::FileResult* CodeSearchResult::mutable_file_results(int index) {
  // @@protoc_insertion_point(field_mutable:CodeSearchResult.file_results)
  return file_results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FileResult >*
CodeSearchResult::mutable_file_results() {
  // @@protoc_insertion_point(field_mutable_list:CodeSearchResult.file_results)
  return &file_results_;
}
inline const ::FileResult& CodeSearchResult::_internal_file_results(int index) const {
  return file_results_.Get(index);
}
inline const ::FileResult& CodeSearchResult::file_results(int index) const {
  // @@protoc_insertion_point(field_get:CodeSearchResult.file_results)
  return _internal_file_results(index);
}
inline ::FileResult* CodeSearchResult::_internal_add_file_results() {
  return file_results_.Add();
}
inline ::FileResult* CodeSearchResult::add_file_results() {
  ::FileResult* _add = _internal_add_file_results();
  // @@protoc_insertion_point(field_add:CodeSearchResult.file_results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FileResult >&
CodeSearchResult::file_results() const {
  // @@protoc_insertion_point(field_list:CodeSearchResult.file_results)
  return file_results_;
}

// string index_name = 4;
inline void CodeSearchResult::clear_index_name() {
  index_name_.ClearToEmpty();
}
inline const std::string& CodeSearchResult::index_name() const {
  // @@protoc_insertion_point(field_get:CodeSearchResult.index_name)
  return _internal_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CodeSearchResult::set_index_name(ArgT0&& arg0, ArgT... args) {
 
 index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CodeSearchResult.index_name)
}
inline std::string* CodeSearchResult::mutable_index_name() {
  std::string* _s = _internal_mutable_index_name();
  // @@protoc_insertion_point(field_mutable:CodeSearchResult.index_name)
  return _s;
}
inline const std::string& CodeSearchResult::_internal_index_name() const {
  return index_name_.Get();
}
inline void CodeSearchResult::_internal_set_index_name(const std::string& value) {
  
  index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CodeSearchResult::_internal_mutable_index_name() {
  
  return index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CodeSearchResult::release_index_name() {
  // @@protoc_insertion_point(field_release:CodeSearchResult.index_name)
  return index_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CodeSearchResult::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    
  } else {
    
  }
  index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CodeSearchResult.index_name)
}

// int64 index_time = 5;
inline void CodeSearchResult::clear_index_time() {
  index_time_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CodeSearchResult::_internal_index_time() const {
  return index_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CodeSearchResult::index_time() const {
  // @@protoc_insertion_point(field_get:CodeSearchResult.index_time)
  return _internal_index_time();
}
inline void CodeSearchResult::_internal_set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  index_time_ = value;
}
inline void CodeSearchResult::set_index_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index_time(value);
  // @@protoc_insertion_point(field_set:CodeSearchResult.index_time)
}

// -------------------------------------------------------------------

// InfoRequest

// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::SearchStats_ExitReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SearchStats_ExitReason>() {
  return ::SearchStats_ExitReason_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_livegrep_2eproto
